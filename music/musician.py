"""Domain classes and functions related to the concept of musician
"""

# from util import utility
from music.enums import Vocals, Instrument
import json


class Musician:
    """The class describing the concept of musician.
    It is assumed that a musician is sufficiently described by their
    name and whether they are a solo musician or a member of a band.

    This class illustrates some of the important concepts of Python classes:
    - self
    - __init__()
    - __str__()
    - __eq__(self, other) is the equivalent of Java equals() and should be overridden in classes
    - __dict__ attribute of all objects ()
    - data fields (instance variables)
    - methods - calling them by self.<method>(...) from the same class where they are defined
    """

    def __init__(self, name, is_band_member=True):
        self.name = name
        self.is_band_member = is_band_member
        self.__n = 'lll'                                    # 'private' field

    # Properties: 'private' fields; run setters and getters in the debugger.
    # Make name a property (after setting up __init__(), __str__(), __eq__(), methods,...).

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name if name and isinstance(name, str) else 'unknown'

    # Add an immutable property (no setter for it)

    @property
    def complete_info(self):
        return self

    def __str__(self):
        band_member_str = f'band member' if self.is_band_member else 'solo musician'
        return f'{self.name}, {band_member_str}'

    def __eq__(self, other):
        # return True if isinstance(other, Musician) and \
        #                other.name == self.name and \
        #                other.is_band_member == self.is_band_member \
        #             else False
        # return isinstance(other, Musician) and other.name == self.name and other.is_band_member == self.is_band_member
        isi = isinstance(other, Musician)
        n = other.name == self.name
        b = other.is_band_member == self.is_band_member
        return isi and n and b

    def play(self, song_title, *args, **kwargs):
        """Assumes that song_title, *args (expressions of gratitude) and kwargs.values() (messages) are strings.
        Prints song_title, rhythm counts, expressions of gratitude and messages. A call example:
            <musician>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        """

        rhythm_count = kwargs['rhythm_count'] if 'rhythm_count' in kwargs.keys() else ''
        messages = ' '.join([v for k, v in kwargs.items() if not k == 'rhythm_count']) if kwargs else ''
        return f'{self.name} playing: {rhythm_count}! - {song_title} - {" ".join(arg for arg in args)}{messages}'

    def play_song(self, song_title, *args, **kwargs):
        """Demonstrates calling another method from the same class (self.<method>(...) as a mandatory syntax).
        """

        return self.play(song_title, *args, **kwargs)

    # Alternative constructor
    @classmethod
    def from_str(cls, musician_string):
        """Inverted __str__() method.
        Assumes that musician_string is in the format generated by __str__().
        """

        words = [word.rstrip(',') for word in musician_string.split()]
        return cls(' '.join(words[:-2]), True if words[-1] == 'member' else False)


class MusicianEncoder(json.JSONEncoder):
    """JSON encoder for musician objects.
    """

    def default(self, o):
        # recommendation: always use double quotes with JSON

        pass


def musician_json_to_py(musician_json):
    """JSON decoder for Musician objects (object_hook parameter in json.loads()).
    """


class Singer(Musician):
    """The class describing the concept of singer.
    It is assumed that a singer is sufficiently described as a Musician,
    with the addition of whether they are a lead or a background singer.
    """

    # # Version 1 - no multiple inheritance
    # def __init__(self, name, vocals, is_band_member=True):
    #     super().__init__(name, is_band_member)
    #     self.vocals = vocals if isinstance(vocals, Vocals) else None

    # Version 2 - with multiple inheritance
    def __init__(self, vocals, **kwargs):
        super().__init__(**kwargs)
        self.vocals = vocals if isinstance(vocals, Vocals) else None

    def __str__(self):
        return super().__str__() + f'; {str(self.vocals.name).lower().replace("_", " ")}'

    def __eq__(self, other):
        # return super().__eq__(other) and self.vocals == other.vocals if isinstance(other, Singer) else False
        # return super().__eq__(other) and (self.vocals == other.vocals) if isinstance(other, Singer) else False
        return isinstance(other, Singer) and super().__eq__(other) and (self.vocals == other.vocals)

    def play(self, song_title, *args, **kwargs):
        """Overrides the play() method from superclass.
        Assumes that song_title, *args (expressions of gratitude) and kwargs.values() (messages) are strings.
        Prints song_title, expressions of gratitude and messages. A call example:
            <singer>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        """

        return super().play(song_title, *args, **kwargs) + '\n' + 'Yeah!'


class Songwriter(Musician):
    """The class describing the concept of songwriter.
    It is assumed that a songwriter is sufficiently described as a musician
    who writes songs and plays an instrument.
    """

    # # Version 1 - no multiple inheritance
    # def __init__(self, name, instrument, is_band_member=True):
    #     super().__init__(name, is_band_member)
    #     self.instrument = instrument if isinstance(instrument, Instrument) else None
    #     self.writes_songs = True

    # Version 2 - with multiple inheritance
    def __init__(self, instrument, **kwargs):
        super().__init__(**kwargs)
        self.instrument = instrument if isinstance(instrument, Instrument) else None

    def __str__(self):
        return super().__str__() + '; ' + self.instrument.name.lower().replace('_', ' ')

    def __eq__(self, other):
        return isinstance(other, Songwriter) and super().__eq__(other) and self.instrument == other.instrument

    def what_do_you_do(self):
        """Just a simple method to describe the concept of songwriter.
        """

        name = f'I am {self.name}'
        songwriter = f', a songwriter' if self.writes_songs else ''
        instrument = f'; I also play {self.instrument}.' if self.instrument else '.'
        print(name + songwriter + instrument)


class SingerSongwriter(Singer, Songwriter):
    """The class describing the concept of singer-songwriter.
    It is assumed that a singer-songwriter is sufficiently described as a Singer who is simultaneously a Songwriter.
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def __str__(self):
        return super().__str__() + f'; {str(self.instrument.name).lower().replace("_", " ")}'


if __name__ == "__main__":

    # from testdata.musicians import *

    johnLennon = Musician('John Lennon', is_band_member=True)

    # Print objects
    print(johnLennon)
    print()

    # Compare objects
    johnL = Musician('John Lennon', is_band_member=False)
    print(johnLennon == johnL)
    print()

    # Access data fields (instance variables), including 'private' fields
    print(johnLennon.name)
    print(johnLennon.complete_info)
    # print(johnLennon._n)              # works, with a "warning" (Access to a protected member _n of a class)
    # print(johnLennon._Musician_n)     # doesn't work
    # print(johnLennon.__n)             # doesn't work, __n is "private"
    # print(johnLennon._Musician__n)    # works, with a "warning" (Access to a protected member _Musician__n of a class)
    print()

    # Add new data fields (instance variables)
    #   1. <object>.<new_attr> = <value>
    #   2. <object>.__setattr__('<new_attr>', <value>)      # counterpart: <object>.__getattribute__('<attr>')
    #   3. setattr(<object>, '<new_attr>', <value>))        # counterpart: getattr(<object>, '<attr>')
    print()

    # Calling methods
    print(johnLennon.play('I Saw Her Standing There', 'Thank you!',
                          rhythm_count='One, two, three, four',
                          end='Good night!'))
    print(johnLennon.play_song('I Saw Her Standing There', 'Thank you!',
                               rhythm_count='One, two, three, four',
                               end='Good night!'))
    print()

    # # Demonstrate object data fields and methods for some built-in classes (boolean, int, object,...)
    # print(True + 1)
    # print(True.__int__())
    # print((1).__class__)
    # print((1).__class__.__name__)
    # print((1).__dir__())
    # print(object.__dict__)
    # print()

    # # Demonstrate object data fields and methods for Musician objects
    # print(johnLennon.__dir__())
    # print(johnLennon.__dict__)
    # print(Musician.__dict__)
    # print()

    # Demonstrate @classmethod (from_str())
    j = str(johnLennon)
    print(j)
    print(johnLennon.from_str(j))
    print(Musician.from_str(j))
    print()

    # Demonstrate inheritance
    # object class (like the Object class in Java; all classes inherit from object
    #   try, e.g., list.__mro__ in the console)
    #   object class defines object.__eq__(self, other) etc.
    #   object.__ne__(self, other), the inverse of object.__eq__(self, other),
    #   is provided by Python automatically once object.__eq__(self, other) is implemented
    j = Singer(name='John Lennon', vocals=Vocals.LEAD_VOCALS, is_band_member=True)
    print(j)
    print()

    print(type(j))
    print(isinstance(j, Musician))          # True, since a Singer object is a kind of Musician object

    print(j == Singer(name='John Lennon', vocals=Vocals.LEAD_VOCALS, is_band_member=True))
    print(j == Singer(name='John Lennon', vocals=Vocals.LEAD_VOCALS, is_band_member=True))
    print()

    jl = Songwriter(name='John Lennon', instrument=Instrument.RHYTHM_GUITAR, is_band_member=True)
    print(jl)
    print(jl == Songwriter(name='John Lennon', instrument=Instrument.RHYTHM_GUITAR, is_band_member=False))
    print()

    # Demonstrate method overriding
    j = Singer(name='John Lennon', vocals=Vocals.LEAD_VOCALS, is_band_member=True)
    print(j.play('Stand By Me', rhythm_count='...three, four!', bye='Good Night!'))
    print()

    # Demonstrate multiple inheritance and MRO.
    # Make sure to read this first: https://stackoverflow.com/a/50465583/1899061 (especially Scenario 3).
    lennon = SingerSongwriter(name='John Lennon',
                              vocals=Vocals.LEAD_VOCALS,
                              instrument=Instrument.RHYTHM_GUITAR,
                              is_band_member=True)
    print(lennon)
    print()
    print(SingerSongwriter.__mro__)
    print()

    # Demonstrate JSON encoding/decoding of Performer objects
    # Single object
    print()

    # List of objects
    print()
